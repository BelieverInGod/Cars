var Promise = require("bluebird");
var cp = require('child_process');
Promise.promisifyAll(cp);
var semver = require('semver');

module.exports = function(buildType){

  switch(buildType){

    case 'prod':
      return getVersionFromLastTag().then(function(num) {
      return {
        semver: num,
        dotnetversion: num + '.0'
      };
    });

    case 'test':
      return getNextVersionFromBranchName().then(function(num) {
      return getCommitsSinceLastTag().then(function(sub) {
        return {
          semver: num + '-test-' + sub,
          dotnetversion: num + '.' + sub
        };
      });
    });

    case 'labs':
      case 'develop':
      case 'demo':
      return getCommitsSinceRootTag().then(function(sub) {
      return {
        semver: '0.0.0-' + buildType + '-' + sub,
        dotnetversion: '0.0.0.' + sub
      };
    });

    default:
      return getVersionFromLastTag().then(function(num) {
      _v = incrementPatchNumber(num);

      return {
        semver: _v + '-local-' + Date.now(),
        dotnetversion: _v + '.0'
      };
    });

  }
};

function getVersionFromLastTag() {
  return cp.execAsync('git remote update')
  .then(function() {
    return cp.execAsync('git describe --abbrev=0 origin/master')
  })
  .spread(function(stdout, stderr) {
    return stdout.trim();
  });
}


function getNextVersionFromBranchName() {
  return cp.execAsync('git rev-parse --abbrev-ref HEAD')
  .spread(function(stdout, stderr) {
    return stdout.trim().split('/')[1];
  });
}


function getCommitsSinceLastTag() {
  return cp.execAsync('git describe')
  .spread(function(stdout, stderr) {
    return stdout.trim().split('-')[1] || 0;
  });
}

function getCommitsSinceRootTag() {
  return cp.execAsync('git describe --match root --tags')
  .spread(function(stdout, stderr) {
    return stdout.trim().split('-')[1] || 0;
  });
}

function incrementPatchNumber(releaseSemver) {
  return semver.inc(releaseSemver, 'patch');
}
